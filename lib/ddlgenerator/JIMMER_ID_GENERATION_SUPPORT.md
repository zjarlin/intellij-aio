# Jimmer ID生成策略支持

## 概述

根据Jimmer官方文档完善了对所有ID生成策略的支持，包括数据库自动编号、序列、UUID和自定义生成器。

## 支持的ID生成策略

### 1. 数据库自动编号（IDENTITY）

最常用的ID生成方式，由数据库自动管理ID值。

#### Jimmer定义

```java
@Entity
public interface Book {
    @Id
    @GeneratedValue  // 默认strategy=IDENTITY
    Long id();
    
    // 或显式指定
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long id();
}
```

#### 检测逻辑

```kotlin
val LsiField.isAutoIncrement: Boolean
    get() {
        if (!hasAnnotationIgnoreCase("GeneratedValue")) {
            return false
        }
        
        val strategy = getArg("GeneratedValue", "strategy")
        
        // 如果没有指定strategy，默认为IDENTITY（Jimmer默认）
        if (strategy == null) {
            return true
        }
        
        // 检查是否为IDENTITY或AUTO
        return strategy.containsAnyIgnoreCase("IDENTITY", "AUTO")
    }
```

#### 生成的DDL

**MySQL:**
```sql
CREATE TABLE `book` (
    `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    ...
);
```

**PostgreSQL:**
```sql
CREATE TABLE "book" (
    "id" BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ...
);
```

### 2. 数据库序列（SEQUENCE）

使用数据库序列生成ID，适合Oracle、PostgreSQL等数据库。

#### Jimmer定义

```java
@Entity
public interface Book {
    @Id
    @GeneratedValue(
        strategy = GenerationType.SEQUENCE,
        generatorName = "book_id_seq"
    )
    Long id();
}
```

#### 检测逻辑

```kotlin
val LsiField.isSequence: Boolean
    get() {
        if (!hasAnnotationIgnoreCase("GeneratedValue")) {
            return false
        }
        
        val strategy = getArg("GeneratedValue", "strategy")
        return strategy?.contains("SEQUENCE", ignoreCase = true) ?: false
    }

val LsiField.sequenceName: String?
    get() {
        if (!isSequence) {
            return null
        }
        return getArg("GeneratedValue", "generatorName")
    }
```

#### 生成的DDL

**PostgreSQL:**
```sql
-- 1. 创建序列
CREATE SEQUENCE IF NOT EXISTS "book_id_seq" INCREMENT BY 1 START WITH 1;

-- 2. 创建表并使用序列
CREATE TABLE "book" (
    "id" BIGINT NOT NULL DEFAULT nextval('book_id_seq') PRIMARY KEY,
    ...
);
```

**说明：**
- PostgreSQL会自动创建所需的序列
- 如果未指定`generatorName`，默认使用 `${columnName}_seq`
- 序列在表创建之前生成

### 3. UUID生成器

使用UUID作为主键，适合分布式系统。

#### Jimmer定义

```java
@Entity
public interface Book {
    @Id
    @GeneratedValue(generatorType = UUIDIdGenerator.class)
    UUID id();
}
```

#### 检测逻辑

```kotlin
val LsiField.isUUID: Boolean
    get() {
        if (!hasAnnotationIgnoreCase("GeneratedValue")) {
            return false
        }
        
        val generatorType = getArg("GeneratedValue", "generatorType")
        return generatorType?.contains("UUIDIdGenerator", ignoreCase = true) ?: false
    }
```

#### 生成的DDL

```sql
-- UUID由应用层生成，DDL无需特殊处理
CREATE TABLE "book" (
    "id" UUID NOT NULL PRIMARY KEY,
    ...
);
```

**说明：**
- UUID由应用层（Jimmer框架）生成
- DDL中不需要AUTO_INCREMENT或SEQUENCE
- PostgreSQL使用UUID类型，MySQL使用CHAR(36)或BINARY(16)

### 4. 自定义IdGenerator

使用用户自定义的ID生成器。

#### Jimmer定义

```java
public class MyIdGenerator implements UserIdGenerator<Long> {
    @Override
    public Long generate(Class<?> entityType) {
        // 自定义ID生成逻辑
        return ...;
    }
}

@Entity
public interface Book {
    @Id
    @GeneratedValue(generatorType = MyIdGenerator.class)
    Long id();
}
```

#### 检测逻辑

```kotlin
val LsiField.hasCustomIdGenerator: Boolean
    get() {
        if (!hasAnnotationIgnoreCase("GeneratedValue")) {
            return false
        }
        
        val generatorType = getArg("GeneratedValue", "generatorType")
        // 如果有generatorType但不是UUIDIdGenerator，说明是自定义的
        return generatorType != null && !generatorType.contains("UUIDIdGenerator", ignoreCase = true)
    }

val LsiField.customIdGeneratorType: String?
    get() {
        if (!hasCustomIdGenerator) {
            return null
        }
        return getArg("GeneratedValue", "generatorType")
    }
```

#### 生成的DDL

```sql
-- 自定义生成器由应用层处理，DDL无需特殊处理
CREATE TABLE "book" (
    "id" BIGINT NOT NULL PRIMARY KEY,
    ...
);
```

## API使用示例

### 检测ID生成策略

```kotlin
val field: LsiField = ... // 获取字段

when {
    field.isAutoIncrement -> {
        println("使用数据库自动编号")
    }
    field.isSequence -> {
        val seqName = field.sequenceName ?: "default_seq"
        println("使用数据库序列: $seqName")
    }
    field.isUUID -> {
        println("使用UUID生成器")
    }
    field.hasCustomIdGenerator -> {
        val generatorType = field.customIdGeneratorType
        println("使用自定义生成器: $generatorType")
    }
    else -> {
        println("无ID生成策略（手动赋值）")
    }
}
```

### 生成DDL

```kotlin
import site.addzero.util.ddlgenerator.toCreateTableDDL
import site.addzero.util.db.DatabaseType

// 自动处理所有ID生成策略
val ddl = bookLsiClass.toCreateTableDDL(DatabaseType.POSTGRESQL)
println(ddl)

// 批量生成（自动创建序列）
val schema = listOf(book, author, publisher).toSchemaDDL(DatabaseType.POSTGRESQL)
```

## 完成的功能

### lsi-database模块扩展

- ✅ `LsiField.isAutoIncrement` - 检测数据库自动编号
- ✅ `LsiField.isSequence` - 检测序列生成
- ✅ `LsiField.sequenceName` - 获取序列名称
- ✅ `LsiField.isUUID` - 检测UUID生成器
- ✅ `LsiField.hasCustomIdGenerator` - 检测自定义生成器
- ✅ `LsiField.customIdGeneratorType` - 获取自定义生成器类型

### DDL生成策略增强

**PostgreSqlDdlStrategy:**
- ✅ 支持IDENTITY语法（`GENERATED BY DEFAULT AS IDENTITY`）
- ✅ 支持SEQUENCE语法（`DEFAULT nextval('seq_name')`）
- ✅ 自动创建所需的序列
- ✅ 序列在表之前创建

**MySqlDdlStrategy:**
- ✅ 支持AUTO_INCREMENT语法
- ⚠️ MySQL不原生支持SEQUENCE（通过其他方式模拟）

## 数据库兼容性

| 策略 | MySQL | PostgreSQL | Oracle | SQL Server |
|------|-------|------------|--------|------------|
| IDENTITY | ✅ AUTO_INCREMENT | ✅ IDENTITY | ✅ IDENTITY | ✅ IDENTITY |
| SEQUENCE | ⚠️ 8.0+ | ✅ | ✅ | ✅ |
| UUID | ✅ | ✅ | ✅ | ✅ |
| 自定义 | ✅ | ✅ | ✅ | ✅ |

## 最佳实践

### 1. 选择合适的ID生成策略

- **单机应用**：使用IDENTITY（最简单）
- **分布式系统**：使用UUID或雪花算法（自定义生成器）
- **高性能要求**：使用SEQUENCE（批量预分配）
- **需要业务含义**：使用自定义生成器

### 2. PostgreSQL序列优化

```java
@Entity
public interface Book {
    @Id
    @GeneratedValue(
        strategy = GenerationType.SEQUENCE,
        generatorName = "book_id_seq"
    )
    Long id();
}
```

可以手动创建序列并设置缓存：
```sql
CREATE SEQUENCE book_id_seq 
    INCREMENT BY 1 
    START WITH 1
    CACHE 50;  -- 预分配50个ID，提高性能
```

### 3. UUID性能考虑

```java
// 推荐：使用有序UUID（如ULID）
@Id
@GeneratedValue(generatorType = ULIDIdGenerator.class)
String id();

// 避免：随机UUID会导致索引碎片
@Id
@GeneratedValue(generatorType = UUIDIdGenerator.class)
UUID id();
```

### 4. 自定义生成器示例：雪花算法

```java
public class SnowflakeIdGenerator implements UserIdGenerator<Long> {
    private final Snowflake snowflake;
    
    public SnowflakeIdGenerator() {
        // 从配置获取workerId和datacenterId
        this.snowflake = new Snowflake(workerId, datacenterId);
    }
    
    @Override
    public Long generate(Class<?> entityType) {
        return snowflake.nextId();
    }
}

@Entity
public interface Book {
    @Id
    @GeneratedValue(generatorType = SnowflakeIdGenerator.class)
    Long id();
}
```

## 注意事项

1. **IDENTITY vs SEQUENCE**
   - IDENTITY：每次插入时请求数据库，可能影响批量插入性能
   - SEQUENCE：可以批量预分配，性能更好

2. **UUID存储**
   - PostgreSQL有原生UUID类型，性能最优
   - MySQL建议使用BINARY(16)而非CHAR(36)节省空间

3. **自定义生成器**
   - 必须是无参构造器或Spring Bean
   - 需要考虑线程安全和分布式环境

4. **DDL生成限制**
   - MySQL 8.0+才支持序列
   - UUID和自定义生成器不影响DDL结构

## 参考文档

- [Jimmer官方文档 - 数据库自动编号](https://jimmer.coooolfan.com/zh/docs/mapping/base/basic#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7)
- [PostgreSQL IDENTITY vs SEQUENCE](https://www.postgresql.org/docs/current/sql-createtable.html)
- [MySQL AUTO_INCREMENT](https://dev.mysql.com/doc/refman/8.0/en/example-auto-increment.html)
