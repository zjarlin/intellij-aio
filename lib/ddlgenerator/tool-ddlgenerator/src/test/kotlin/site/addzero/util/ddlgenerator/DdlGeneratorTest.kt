package site.addzero.util.ddlgenerator

import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import site.addzero.util.ddlgenerator.inter.MetadataExtractor
import site.addzero.util.ddlgenerator.inter.TableContext
import site.addzero.util.ddlgenerator.model.*
import java.util.ServiceLoader
import kotlin.test.assertEquals
import kotlin.test.assertFalse
import kotlin.test.assertTrue

class DdlGeneratorTest {

    // 简单的TableContext实现用于测试
    class SimpleTableContext(private val tables: List<TableDefinition>) : TableContext {
        override fun getTableDefinitions(): List<TableDefinition> = tables

        override fun getTableDefinition(tableName: String): TableDefinition? {
            return tables.find { it.name == tableName }
        }

        override fun getTableDependencies(): Map<String, List<String>> {
            val dependencies = mutableMapOf<String, List<String>>()
            for (table in tables) {
                val tableDependencies = mutableListOf<String>()
                for (fk in table.foreignKeys) {
                    tableDependencies.add(fk.referencedTable)
                }
                dependencies[table.name] = tableDependencies
            }
            return dependencies
        }

        override fun getDependentTables(tableName: String): List<String> {
            val dependents = mutableListOf<String>()
            for (table in tables) {
                for (fk in table.foreignKeys) {
                    if (fk.referencedTable == tableName) {
                        dependents.add(table.name)
                    }
                }
            }
            return dependents
        }
    }

    @Test
    fun testMySQLDDLGeneration() {
        val generator = DdlGeneratorFactory.create(Dialect.MYSQL)

        val table = TableDefinition(
            name = "users",
            columns = listOf(
                ColumnDefinition(
                    name = "id",
                    type = ColumnType.BIGINT,
                    primaryKey = true,
                    autoIncrement = true,
                    nullable = false
                ),
                ColumnDefinition(
                    name = "username",
                    type = ColumnType.VARCHAR,
                    nullable = false,
                    comment = "用户名"
                ),
                ColumnDefinition(
                    name = "email",
                    type = ColumnType.VARCHAR,
                    nullable = true
                ),
                ColumnDefinition(
                    name = "created_at",
                    type = ColumnType.TIMESTAMP,
                    defaultValue = "CURRENT_TIMESTAMP"
                )
            ),
            comment = "用户表"
        )

        val ddl = generator.createTable(table)
        assertTrue(ddl.contains("CREATE TABLE `users`"))
        assertTrue(ddl.contains("`id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY"))
        assertTrue(ddl.contains("`username` VARCHAR(255) NOT NULL"))
        assertTrue(ddl.contains("`email` VARCHAR(255)"))
        assertTrue(ddl.contains("`created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP"))
        assertFalse(ddl.contains("COMMENT='用户表'")) // 注释应该在单独的语句中添加
    }

    @Test
    fun testPostgreSQLDDLGeneration() {
        val generator = DdlGeneratorFactory.create(Dialect.POSTGRESQL)

        val table = TableDefinition(
            name = "users",
            columns = listOf(
                ColumnDefinition(
                    name = "id",
                    type = ColumnType.BIGINT,
                    primaryKey = true,
                    autoIncrement = true,
                    nullable = false
                ),
                ColumnDefinition(
                    name = "username",
                    type = ColumnType.VARCHAR,
                    nullable = false
                ),
                ColumnDefinition(
                    name = "email",
                    type = ColumnType.VARCHAR,
                    nullable = true
                ),
                ColumnDefinition(
                    name = "created_at",
                    type = ColumnType.TIMESTAMP,
                    defaultValue = "CURRENT_TIMESTAMP"
                )
            ),
            comment = "用户表"
        )

        val ddl = generator.createTable(table)
        assertTrue(ddl.contains("CREATE TABLE \"users\""))
        assertTrue(ddl.contains("\"id\" BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY"))
        assertTrue(ddl.contains("\"username\" VARCHAR(255) NOT NULL"))
        assertTrue(ddl.contains("\"email\" VARCHAR(255)"))
        assertTrue(ddl.contains("\"created_at\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP"))
        assertFalse(ddl.contains("COMMENT ON TABLE")) // 注释应该在单独的语句中添加
    }

    @Test
    fun testUnsupportedDialectThrowsException() {
        assertThrows<NotImplementedError> {
            DdlGeneratorFactory.create(Dialect.ORACLE)
        }

        assertThrows<IllegalArgumentException> {
            DdlGeneratorFactory.create("unsupported_dialect")
        }
    }

    @Test
    fun testDropTableGeneration() {
        val mysqlGenerator = DdlGeneratorFactory.create(Dialect.MYSQL)
        val mysqlDdl = mysqlGenerator.dropTable("users")
        assertEquals("DROP TABLE IF EXISTS `users`;", mysqlDdl)

        val postgresGenerator = DdlGeneratorFactory.create(Dialect.POSTGRESQL)
        val postgresDdl = postgresGenerator.dropTable("users")
        assertEquals("DROP TABLE IF EXISTS \"users\";", postgresDdl)
    }

    @Test
    fun testAddColumnGeneration() {
        val generator = DdlGeneratorFactory.create(Dialect.MYSQL)
        val column = ColumnDefinition(
            name = "age",
            type = ColumnType.INT,
            nullable = true,
            defaultValue = "0"
        )

        val ddl = generator.addColumn("users", column)
        assertEquals("ALTER TABLE `users` ADD COLUMN `age` INT DEFAULT 0;", ddl)
    }

    @Test
    fun testDropColumnGeneration() {
        val generator = DdlGeneratorFactory.create(Dialect.MYSQL)
        val ddl = generator.dropColumn("users", "age")
        assertEquals("ALTER TABLE `users` DROP COLUMN `age`;", ddl)
    }

    @Test
    fun testFormattedOutput() {
        val generator = DdlGeneratorFactory.create(Dialect.MYSQL)

        val table = TableDefinition(
            name = "products",
            columns = listOf(
                ColumnDefinition(
                    name = "id",
                    type = ColumnType.BIGINT,
                    primaryKey = true,
                    autoIncrement = true,
                    nullable = false
                ),
                ColumnDefinition(
                    name = "name",
                    type = ColumnType.VARCHAR,
                    nullable = false
                )
            )
        )

        val ddl = generator.createTable(table)
        val lines = ddl.lines()
        assertEquals("CREATE TABLE `products` (", lines[0])
        assertEquals("  `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,", lines[1])
        assertEquals("  `name` VARCHAR(255) NOT NULL", lines[2])
        assertEquals(") AUTO_INCREMENT=1;", lines[3])
    }

    @Test
    fun testServiceLoaderCanLoadStrategies() {
        val loader = ServiceLoader.load(DdlGenerationStrategy::class.java)
        val strategies = loader.toList()

        // 检查是否加载了MySQL和PostgreSQL策略
        assertTrue(strategies.any { it is MySqlDdlGenerationStrategy })
        assertTrue(strategies.any { it is PostgreSqlDdlGenerationStrategy })
    }

    @Test
    fun testStrategySupportsMethod() {
        val mysqlStrategy = MySqlDdlGenerationStrategy()
        assertTrue(mysqlStrategy.supports(Dialect.MYSQL))
        assertFalse(mysqlStrategy.supports(Dialect.POSTGRESQL))

        val postgresStrategy = PostgreSqlDdlGenerationStrategy()
        assertTrue(postgresStrategy.supports(Dialect.POSTGRESQL))
        assertFalse(postgresStrategy.supports(Dialect.MYSQL))
    }

    @Test
    fun testMySQLForeignKeyGeneration() {
        val generator = DdlGeneratorFactory.create(Dialect.MYSQL)

        val userTable = TableDefinition(
            name = "users",
            columns = listOf(
                ColumnDefinition(
                    name = "id",
                    type = ColumnType.BIGINT,
                    primaryKey = true,
                    autoIncrement = true,
                    nullable = false
                )
            )
        )

        val orderTable = TableDefinition(
            name = "orders",
            columns = listOf(
                ColumnDefinition(
                    name = "id",
                    type = ColumnType.BIGINT,
                    primaryKey = true,
                    autoIncrement = true,
                    nullable = false
                ),
                ColumnDefinition(
                    name = "user_id",
                    type = ColumnType.BIGINT,
                    nullable = false
                )
            ),
            foreignKeys = listOf(
                ForeignKeyDefinition(
                    name = "fk_order_user",
                    columnName = "user_id",
                    referencedTable = "users",
                    referencedColumnName = "id"
                )
            )
        )

        val ddl = generator.createTable(orderTable)
        assertFalse(ddl.contains("CONSTRAINT")) // 外键不应该在CREATE TABLE语句中

        val fkDdl = generator.addForeignKey("orders", orderTable.foreignKeys[0])
        assertTrue(fkDdl.contains("ALTER TABLE `orders`"))
        assertTrue(fkDdl.contains("ADD CONSTRAINT `fk_order_user`"))
        assertTrue(fkDdl.contains("FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)"))
    }

    @Test
    fun testPostgreSQLForeignKeyGeneration() {
        val generator = DdlGeneratorFactory.create(Dialect.POSTGRESQL)

        val userTable = TableDefinition(
            name = "users",
            columns = listOf(
                ColumnDefinition(
                    name = "id",
                    type = ColumnType.BIGINT,
                    primaryKey = true,
                    autoIncrement = true,
                    nullable = false
                )
            )
        )

        val orderTable = TableDefinition(
            name = "orders",
            columns = listOf(
                ColumnDefinition(
                    name = "id",
                    type = ColumnType.BIGINT,
                    primaryKey = true,
                    autoIncrement = true,
                    nullable = false
                ),
                ColumnDefinition(
                    name = "user_id",
                    type = ColumnType.BIGINT,
                    nullable = false
                )
            ),
            foreignKeys = listOf(
                ForeignKeyDefinition(
                    name = "fk_order_user",
                    columnName = "user_id",
                    referencedTable = "users",
                    referencedColumnName = "id"
                )
            )
        )

        val ddl = generator.createTable(orderTable)
        assertFalse(ddl.contains("CONSTRAINT")) // 外键不应该在CREATE TABLE语句中

        val fkDdl = generator.addForeignKey("orders", orderTable.foreignKeys[0])
        assertTrue(fkDdl.contains("ALTER TABLE \"orders\""))
        assertTrue(fkDdl.contains("ADD CONSTRAINT \"fk_order_user\""))
        assertTrue(fkDdl.contains("FOREIGN KEY (\"user_id\") REFERENCES \"users\" (\"id\")"))
    }

    @Test
    fun testSchemaGenerationWithMultipleTables() {
        val generator = DdlGeneratorFactory.create(Dialect.MYSQL)

        val userTable = TableDefinition(
            name = "users",
            columns = listOf(
                ColumnDefinition(
                    name = "id",
                    type = ColumnType.BIGINT,
                    primaryKey = true,
                    autoIncrement = true,
                    nullable = false
                ),
                ColumnDefinition(
                    name = "username",
                    type = ColumnType.VARCHAR,
                    nullable = false
                )
            )
        )

        val orderTable = TableDefinition(
            name = "orders",
            columns = listOf(
                ColumnDefinition(
                    name = "id",
                    type = ColumnType.BIGINT,
                    primaryKey = true,
                    autoIncrement = true,
                    nullable = false
                ),
                ColumnDefinition(
                    name = "user_id",
                    type = ColumnType.BIGINT,
                    nullable = false
                )
            ),
            foreignKeys = listOf(
                ForeignKeyDefinition(
                    name = "fk_order_user",
                    columnName = "user_id",
                    referencedTable = "users",
                    referencedColumnName = "id"
                )
            )
        )

        val tables = listOf(userTable, orderTable)
        val schemaDdl = generator.createSchema(tables)

        assertTrue(schemaDdl.contains("CREATE TABLE `users`"))
        assertTrue(schemaDdl.contains("CREATE TABLE `orders`"))
        assertTrue(schemaDdl.contains("ALTER TABLE `orders`"))
        assertTrue(schemaDdl.contains("ADD CONSTRAINT `fk_order_user`"))
        assertTrue(schemaDdl.lines().count { it.contains("CREATE TABLE") } == 2)
    }

    @Test
    fun testDependencyResolution() {
        val userTable = TableDefinition(
            name = "users",
            columns = listOf(
                ColumnDefinition("id", ColumnType.BIGINT, primaryKey = true, autoIncrement = true, nullable = false)
            )
        )

        val orderTable = TableDefinition(
            name = "orders",
            columns = listOf(
                ColumnDefinition("id", ColumnType.BIGINT, primaryKey = true, autoIncrement = true, nullable = false),
                ColumnDefinition("user_id", ColumnType.BIGINT, nullable = false)
            ),
            foreignKeys = listOf(
                ForeignKeyDefinition("fk_order_user", "user_id", "users", "id")
            )
        )

        val tables = listOf(orderTable, userTable) // 故意打乱顺序
        val context = SimpleTableContext(tables)
        val resolver = DependencyResolver()

        // 解析依赖关系，users表应该在orders表之前
        val orderedTables = resolver.resolveCreationOrder(context)
        assertEquals(2, orderedTables.size)
        assertEquals("users", orderedTables[0].name)
        assertEquals("orders", orderedTables[1].name)
    }

    @Test
    fun testSchemaGenerationWithContext() {
        val userTable = TableDefinition(
            name = "users",
            columns = listOf(
                ColumnDefinition("id", ColumnType.BIGINT, primaryKey = true, autoIncrement = true, nullable = false),
                ColumnDefinition("username", ColumnType.VARCHAR, nullable = false)
            )
        )

        val orderTable = TableDefinition(
            name = "orders",
            columns = listOf(
                ColumnDefinition("id", ColumnType.BIGINT, primaryKey = true, autoIncrement = true, nullable = false),
                ColumnDefinition("user_id", ColumnType.BIGINT, nullable = false)
            ),
            foreignKeys = listOf(
                ForeignKeyDefinition("fk_order_user", "user_id", "users", "id")
            )
        )

        val tables = listOf(orderTable, userTable) // 故意打乱顺序
        val context = SimpleTableContext(tables)
        val generator = DdlGeneratorFactory.create(Dialect.MYSQL)

        // 通过上下文生成schema
        val schemaDdl = generator.createSchema(context)

        assertTrue(schemaDdl.contains("CREATE TABLE `users`"))
        assertTrue(schemaDdl.contains("CREATE TABLE `orders`"))
        assertTrue(schemaDdl.contains("ALTER TABLE `orders`"))
        assertTrue(schemaDdl.contains("ADD CONSTRAINT `fk_order_user`"))

        // 检查表的顺序是否正确（依赖表在前）
        val lines = schemaDdl.lines()
        var usersIndex = -1
        var ordersIndex = -1
        var fkIndex = -1
        for (i in lines.indices) {
            if (lines[i].contains("CREATE TABLE `users`")) {
                usersIndex = i
            } else if (lines[i].contains("CREATE TABLE `orders`")) {
                ordersIndex = i
            } else if (lines[i].contains("ADD CONSTRAINT `fk_order_user`")) {
                fkIndex = i
            }
        }

        // users表应该在orders表之前创建，外键应该在所有表创建之后添加
        assertTrue(usersIndex < ordersIndex)
        assertTrue(ordersIndex < fkIndex)
    }

    @Test
    fun testMySQLCommentGeneration() {
        val generator = DdlGeneratorFactory.create(Dialect.MYSQL)

        val table = TableDefinition(
            name = "users",
            columns = listOf(
                ColumnDefinition(
                    name = "id",
                    type = ColumnType.BIGINT,
                    primaryKey = true,
                    autoIncrement = true,
                    nullable = false
                ),
                ColumnDefinition(
                    name = "username",
                    type = ColumnType.VARCHAR,
                    nullable = false,
                    comment = "用户名"
                )
            ),
            comment = "用户表"
        )

        val commentDdl = generator.addComment(table)
        assertTrue(commentDdl.contains("ALTER TABLE `users` COMMENT='用户表';"))
        assertTrue(commentDdl.contains("ALTER TABLE `users` MODIFY `username` VARCHAR(255) COMMENT '用户名';"))
    }

    @Test
    fun testPostgreSQLCommentGeneration() {
        val generator = DdlGeneratorFactory.create(Dialect.POSTGRESQL)

        val table = TableDefinition(
            name = "users",
            columns = listOf(
                ColumnDefinition(
                    name = "id",
                    type = ColumnType.BIGINT,
                    primaryKey = true,
                    autoIncrement = true,
                    nullable = false
                ),
                ColumnDefinition(
                    name = "username",
                    type = ColumnType.VARCHAR,
                    nullable = false,
                    comment = "用户名"
                )
            ),
            comment = "用户表"
        )

        val commentDdl = generator.addComment(table)
        assertTrue(commentDdl.contains("COMMENT ON TABLE \"users\" IS '用户表';"))
        assertTrue(commentDdl.contains("COMMENT ON COLUMN \"users\".\"username\" IS '用户名';"))
    }

    @Test
    fun `test metadata based table context`() {
        // 创建模拟的元数据提取器
        val userExtractor = object : MetadataExtractor {
            override fun extractTableDefinition(): TableDefinition {
                return TableDefinition(
                    name = "users",
                    columns = listOf(
                        ColumnDefinition("id", ColumnType.BIGINT, primaryKey = true, autoIncrement = true, nullable = false),
                        ColumnDefinition("username", ColumnType.VARCHAR, nullable = false)
                    )
                )
            }

            override fun extractDependencies(): List<String> = emptyList()
        }

        val orderExtractor = object : MetadataExtractor {
            override fun extractTableDefinition(): TableDefinition {
                return TableDefinition(
                    name = "orders",
                    columns = listOf(
                        ColumnDefinition("id", ColumnType.BIGINT, primaryKey = true, autoIncrement = true, nullable = false),
                        ColumnDefinition("user_id", ColumnType.BIGINT, nullable = false)
                    ),
                    foreignKeys = listOf(
                        ForeignKeyDefinition("fk_order_user", "user_id", "users", "id")
                    )
                )
            }

            override fun extractDependencies(): List<String> = listOf("users")
        }

        // 使用元数据提取器创建表上下文
        val context = MetadataTableContext.fromExtractors(listOf(userExtractor, orderExtractor))

        // 验证表定义
        val tables = context.getTableDefinitions()
        assertEquals(2, tables.size)
        assertTrue(tables.any { it.name == "users" })
        assertTrue(tables.any { it.name == "orders" })

        // 验证依赖关系
        val dependencies = context.getTableDependencies()
        assertEquals(emptyList<String>(), dependencies["users"])
        assertEquals(listOf("users"), dependencies["orders"])

        // 验证依赖表
        assertEquals(listOf("orders"), context.getDependentTables("users"))
        assertEquals(emptyList<String>(), context.getDependentTables("orders"))
    }
}
