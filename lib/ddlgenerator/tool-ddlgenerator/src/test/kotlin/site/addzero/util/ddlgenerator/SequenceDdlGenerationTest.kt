package site.addzero.util.ddlgenerator

import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import site.addzero.util.db.DatabaseType
import site.addzero.util.ddlgenerator.extension.toCreateTableDDL
import site.addzero.util.ddlgenerator.extension.toSchemaDDL

/**
 * 序列DDL生成测试
 */
class SequenceDdlGenerationTest {

    @Test
    fun `test PostgreSQL SEQUENCE with generator name`() {
        // Given: 使用序列的实体
        val book = createBookWithSequence(
            idAnnotations = listOf(
                mockAnnotation("Id", "Id"),
                mockAnnotation("GeneratedValue", "GeneratedValue", mapOf(
                    "strategy" to "SEQUENCE",
                    "generatorName" to "book_id_seq"
                ))
            )
        )

        // When: 生成PostgreSQL DDL
        val ddl = book.toCreateTableDDL(DatabaseType.POSTGRESQL)

        // Then: 应该包含序列语法
        assertTrue(ddl.contains("DEFAULT nextval('book_id_seq')"), 
            "应该包含序列的DEFAULT语法")
        assertTrue(ddl.contains("\"id\""), "应该包含id字段")
        assertTrue(ddl.contains("BIGINT"), "id应该是BIGINT类型")
        
        println("=== PostgreSQL SEQUENCE DDL ===")
        println(ddl)
    }

    @Test
    fun `test schema generation creates sequence first`() {
        // Given: 多个使用序列的实体
        val book = createBookWithSequence(
            idAnnotations = listOf(
                mockAnnotation("Id", "Id"),
                mockAnnotation("GeneratedValue", "GeneratedValue", mapOf(
                    "strategy" to "SEQUENCE",
                    "generatorName" to "book_id_seq"
                ))
            )
        )

        val author = createAuthorWithSequence(
            idAnnotations = listOf(
                mockAnnotation("Id", "Id"),
                mockAnnotation("GeneratedValue", "GeneratedValue", mapOf(
                    "strategy" to "SEQUENCE",
                    "generatorName" to "author_id_seq"
                ))
            )
        )

        // When: 批量生成schema
        val schema = listOf(book, author).toSchemaDDL(DatabaseType.POSTGRESQL)

        // Then: 序列应该在表之前创建
        val sequenceIndex = schema.indexOf("CREATE SEQUENCE")
        val tableIndex = schema.indexOf("CREATE TABLE")
        
        assertTrue(sequenceIndex >= 0, "应该包含CREATE SEQUENCE语句")
        assertTrue(tableIndex > sequenceIndex, "CREATE SEQUENCE应该在CREATE TABLE之前")
        
        assertTrue(schema.contains("\"book_id_seq\""), "应该创建book_id_seq")
        assertTrue(schema.contains("\"author_id_seq\""), "应该创建author_id_seq")
        assertTrue(schema.contains("INCREMENT BY 1"), "序列应该递增1")
        assertTrue(schema.contains("START WITH 1"), "序列应该从1开始")
        
        println("=== PostgreSQL Schema with SEQUENCE ===")
        println(schema)
    }

    @Test
    fun `test IDENTITY generation - no sequence`() {
        // Given: 使用IDENTITY的实体
        val book = createBookWithIdentity()

        // When: 生成PostgreSQL DDL
        val ddl = book.toCreateTableDDL(DatabaseType.POSTGRESQL)

        // Then: 应该使用IDENTITY语法，不应该有序列
        assertTrue(ddl.contains("GENERATED BY DEFAULT AS IDENTITY"), 
            "应该使用IDENTITY语法")
        assertFalse(ddl.contains("nextval"), 
            "IDENTITY不应该使用序列")
        assertFalse(ddl.contains("CREATE SEQUENCE"), 
            "IDENTITY不应该创建序列")
        
        println("=== PostgreSQL IDENTITY DDL ===")
        println(ddl)
    }

    @Test
    fun `test MySQL AUTO_INCREMENT - no sequence support`() {
        // Given: 使用自增的实体
        val book = createBookWithIdentity()

        // When: 生成MySQL DDL
        val ddl = book.toCreateTableDDL(DatabaseType.MYSQL)

        // Then: MySQL应该使用AUTO_INCREMENT
        assertTrue(ddl.contains("AUTO_INCREMENT"), 
            "MySQL应该使用AUTO_INCREMENT")
        assertFalse(ddl.contains("SEQUENCE"), 
            "MySQL不支持序列语法")
        
        println("=== MySQL AUTO_INCREMENT DDL ===")
        println(ddl)
    }

    @Test
    fun `test mixed ID strategies in schema`() {
        // Given: 混合使用IDENTITY和SEQUENCE的实体
        val bookWithIdentity = createBookWithIdentity()
        val authorWithSequence = createAuthorWithSequence(
            idAnnotations = listOf(
                mockAnnotation("Id", "Id"),
                mockAnnotation("GeneratedValue", "GeneratedValue", mapOf(
                    "strategy" to "SEQUENCE",
                    "generatorName" to "author_id_seq"
                ))
            )
        )

        // When: 批量生成schema
        val schema = listOf(bookWithIdentity, authorWithSequence).toSchemaDDL(DatabaseType.POSTGRESQL)

        // Then: 应该同时支持两种策略
        assertTrue(schema.contains("CREATE SEQUENCE"), 
            "应该创建序列（author使用）")
        assertTrue(schema.contains("GENERATED BY DEFAULT AS IDENTITY"), 
            "应该使用IDENTITY（book使用）")
        assertTrue(schema.contains("DEFAULT nextval"), 
            "应该使用序列语法（author使用）")
        
        println("=== Mixed ID Strategies Schema ===")
        println(schema)
    }

    @Test
    fun `test sequence without explicit generator name`() {
        // Given: SEQUENCE策略但未指定generatorName
        val book = createBookWithSequence(
            idAnnotations = listOf(
                mockAnnotation("Id", "Id"),
                mockAnnotation("GeneratedValue", "GeneratedValue", mapOf(
                    "strategy" to "SEQUENCE"
                    // 注意：未指定generatorName
                ))
            )
        )

        // When: 生成DDL
        val ddl = book.toCreateTableDDL(DatabaseType.POSTGRESQL)

        // Then: 应该使用默认的序列名（field_seq）
        assertTrue(ddl.contains("nextval"), "应该使用序列")
        // 因为我们的mock中columnName为null，会使用字段名_seq
        
        println("=== SEQUENCE without explicit name ===")
        println(ddl)
    }

    @Test
    fun `test no duplicate sequences in schema`() {
        // Given: 两个实体使用相同的序列名
        val book1 = createBookWithSequence(
            idAnnotations = listOf(
                mockAnnotation("Id", "Id"),
                mockAnnotation("GeneratedValue", "GeneratedValue", mapOf(
                    "strategy" to "SEQUENCE",
                    "generatorName" to "common_id_seq"
                ))
            )
        )
        
        val book2 = createBookWithSequence(
            className = "Book2",
            tableName = "book2",
            idAnnotations = listOf(
                mockAnnotation("Id", "Id"),
                mockAnnotation("GeneratedValue", "GeneratedValue", mapOf(
                    "strategy" to "SEQUENCE",
                    "generatorName" to "common_id_seq"
                ))
            )
        )

        // When: 批量生成schema
        val schema = listOf(book1, book2).toSchemaDDL(DatabaseType.POSTGRESQL)

        // Then: 相同的序列只应该创建一次
        val sequenceCount = schema.split("CREATE SEQUENCE").size - 1
        assertEquals(1, sequenceCount, "相同的序列应该只创建一次")
        
        println("=== Schema with Shared Sequence ===")
        println(schema)
    }

    // ============ Mock对象工厂 ============

    private fun createBookWithSequence(
        className: String = "Book",
        tableName: String = "book",
        idAnnotations: List<site.addzero.util.lsi.anno.LsiAnnotation>
    ) = mockClass(
        name = className,
        qualifiedName = "com.example.$className",
        tableName = tableName,
        fields = listOf(
            mockField(
                name = "id",
                typeName = "Long",
                qualifiedTypeName = "kotlin.Long",
                comment = "主键",
                annotations = idAnnotations,
                isNullable = false,
                isPrimitive = true
            ),
            mockField(
                name = "name",
                typeName = "String",
                comment = "书名",
                isNullable = false
            )
        )
    )

    private fun createBookWithIdentity() = mockClass(
        name = "Book",
        qualifiedName = "com.example.Book",
        tableName = "book",
        fields = listOf(
            mockField(
                name = "id",
                typeName = "Long",
                qualifiedTypeName = "kotlin.Long",
                comment = "主键",
                annotations = listOf(
                    mockAnnotation("Id", "Id"),
                    mockAnnotation("GeneratedValue", "GeneratedValue", emptyMap())
                ),
                isNullable = false,
                isPrimitive = true
            ),
            mockField(
                name = "name",
                typeName = "String",
                comment = "书名",
                isNullable = false
            )
        )
    )

    private fun createAuthorWithSequence(
        idAnnotations: List<site.addzero.util.lsi.anno.LsiAnnotation>
    ) = mockClass(
        name = "Author",
        qualifiedName = "com.example.Author",
        tableName = "author",
        fields = listOf(
            mockField(
                name = "id",
                typeName = "Long",
                qualifiedTypeName = "kotlin.Long",
                comment = "主键",
                annotations = idAnnotations,
                isNullable = false,
                isPrimitive = true
            ),
            mockField(
                name = "name",
                typeName = "String",
                comment = "作者名",
                isNullable = false
            )
        )
    )
}
