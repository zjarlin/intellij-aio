package site.addzero.i18n.buddy.refactor

import com.intellij.openapi.command.WriteCommandAction
import com.intellij.openapi.project.Project
import com.intellij.openapi.vfs.LocalFileSystem
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.psi.PsiDocumentManager
import com.intellij.psi.PsiManager
import site.addzero.i18n.buddy.scanner.ScanResult
import site.addzero.i18n.buddy.settings.I18nBuddySettingsService
import java.io.File

/**
 * Performs the actual refactoring:
 * 1. Generates the constant object file with all keys
 * 2. Replaces hardcoded strings with i18n calls
 * 3. Adds import statements to modified files
 */
class I18nRefactorEngine(private val project: Project) {

    fun execute(results: List<ScanResult>) {
        val selected = results.filter { it.selected }
        if (selected.isEmpty()) return

        val settings = I18nBuddySettingsService.getInstance(project).state

        WriteCommandAction.runWriteCommandAction(project, "I18n Buddy: Extract Strings", null, Runnable {
            // 1. Generate constant file
            generateConstantFile(selected, settings)

            // 2. Replace strings in source files (process in reverse offset order per file)
            val byFile = selected.groupBy { it.file }
            for ((vFile, items) in byFile) {
                replaceInFile(vFile, items.sortedByDescending { it.startOffset }, settings)
            }
        })
    }

    private fun generateConstantFile(results: List<ScanResult>, settings: I18nBuddySettingsService.State) {
        val basePath = project.basePath ?: return
        val pkg = settings.constantPackage
        val objName = settings.constantObjectName

        // Deduplicate: same key → same text
        val keyToText = linkedMapOf<String, String>()
        for (r in results) {
            keyToText.putIfAbsent(r.generatedKey, r.text)
        }

        val sb = StringBuilder()
        if (pkg.isNotBlank()) {
            sb.appendLine("package $pkg")
            sb.appendLine()
        }
        sb.appendLine("/**")
        sb.appendLine(" * Auto-generated i18n constant keys.")
        sb.appendLine(" * Generated by I18n Buddy plugin.")
        sb.appendLine(" */")
        sb.appendLine("object $objName {")
        for ((key, text) in keyToText) {
            val escaped = text.replace("\\", "\\\\").replace("\"", "\\\"")
            sb.appendLine("    const val $key = \"$escaped\"")
        }
        sb.appendLine("}")

        // Determine target directory
        val modulePath = settings.constantModulePath
        val moduleDir = if (modulePath.isNotBlank()) {
            val relPath = modulePath.trimStart(':').replace(':', '/')
            "$basePath/$relPath"
        } else {
            basePath
        }

        val pkgPath = pkg.replace('.', '/')
        val srcDir = "$moduleDir/src/main/kotlin" + if (pkgPath.isNotEmpty()) "/$pkgPath" else ""
        val targetDir = File(srcDir)
        if (!targetDir.exists()) targetDir.mkdirs()

        val targetFile = File(targetDir, "$objName.kt")
        targetFile.writeText(sb.toString())

        // Refresh VFS
        LocalFileSystem.getInstance().refreshAndFindFileByPath(targetFile.absolutePath)
    }

    private fun replaceInFile(
        vFile: VirtualFile,
        items: List<ScanResult>,
        settings: I18nBuddySettingsService.State,
    ) {
        val psiFile = PsiManager.getInstance(project).findFile(vFile) ?: return
        val document = PsiDocumentManager.getInstance(project).getDocument(psiFile) ?: return

        val objName = settings.constantObjectName
        val hasComposableItems = items.any { it.inComposable }

        // Replace each string literal (reverse order to preserve offsets)
        for (item in items) {
            val replacement = if (item.inComposable) {
                // @Composable → wrap with i18n function
                settings.callTemplate
                    .replace("{FN}", settings.wrapperFunction)
                    .replace("{LOCALE}", settings.localeExpression)
                    .replace("{OBJ}", objName)
                    .replace("{KEY}", item.generatedKey)
            } else {
                // Non-composable → constant reference only
                "${objName}.${item.generatedKey}"
            }

            document.replaceString(item.startOffset, item.endOffset, replacement)
        }

        PsiDocumentManager.getInstance(project).commitDocument(document)

        // Add imports
        addImports(vFile, settings, hasComposableItems)
    }

    private fun addImports(vFile: VirtualFile, settings: I18nBuddySettingsService.State, includeI18nImports: Boolean) {
        val psiFile = PsiManager.getInstance(project).findFile(vFile) ?: return
        val document = PsiDocumentManager.getInstance(project).getDocument(psiFile) ?: return
        val text = document.text

        val importsToAdd = mutableListOf<String>()

        // Wrapper function import — only needed if file has @Composable strings
        if (includeI18nImports && settings.wrapperFunctionImport.isNotBlank()) {
            val imp = "import ${settings.wrapperFunctionImport}"
            if (imp !in text) importsToAdd.add(imp)
        }

        // Locale expression import — only needed if file has @Composable strings
        if (includeI18nImports && settings.localeExpressionImport.isNotBlank()) {
            val imp = "import ${settings.localeExpressionImport}"
            if (imp !in text) importsToAdd.add(imp)
        }

        // Constant object import
        if (settings.constantPackage.isNotBlank()) {
            val imp = "import ${settings.constantPackage}.${settings.constantObjectName}"
            if (imp !in text) importsToAdd.add(imp)
        }

        if (importsToAdd.isEmpty()) return

        // Find insertion point: after last existing import, or after package declaration
        val lines = text.lines()
        var insertLine = 0
        for ((i, line) in lines.withIndex()) {
            val trimmed = line.trim()
            if (trimmed.startsWith("import ")) {
                insertLine = i + 1
            } else if (trimmed.startsWith("package ") && insertLine == 0) {
                insertLine = i + 1
            }
        }

        val insertOffset = if (insertLine > 0) {
            document.getLineStartOffset(insertLine.coerceAtMost(document.lineCount - 1))
        } else {
            0
        }

        val importBlock = importsToAdd.joinToString("\n") + "\n"
        document.insertString(insertOffset, importBlock)
        PsiDocumentManager.getInstance(project).commitDocument(document)
    }
}
